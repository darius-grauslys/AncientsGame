
    
        Okay honestly, the engine isn't in such a weird state.

        (( ready to migrate, need ui_tool update. ))
        1) Remove all asset utilization in backend. For now just do SDL, and then
        do NDS afterwards. This is mainly in sdl_ui.h and sdl_gfx_window_manager.h
        as they use the grit ui_tile indices. Make PLATFORM_ functions to set
        UI_Tile_Maps of the PLATFORM_gfx_windows. On NDS this will just result in
        modifying the graphics memory directly.

            Need to update the .xml files to gen buildable code.    (done)
            Need to add ui_background to core.                      (skip, don't use)
            Need to make sure built code works                      (almost, needs ui_windows to all be registered)

        (( ready for modification ))
        2) f_tile_render_kernel(Chunk_Map_Node *p.., Local_Vec3);
           PLATFORM_render_tile(gfx_context, gfx_window, Camera p.., u16 tile_texture_index, Tile_Vec3);

            f_tile_render_kernel - gives core a kernel means to manipulate tile rendering
                for example: walls.
            PLATFORM_render_tile - puts a tile into a gfx window at the given position
                relative to the camera.
            
            This gives CORE an agnostic means to control tile rendering. Can also add:
            PLATFORM_render_voxel(...); at a future date.

                For this we want good spacial locality. Currently, on NDS and SDL the following occurs:
                For each tile in chunk, get a tile_render_result, and use that to update all three
                graphics windows at the same time. If we looped over each individual window we would
                get bad spacial locality.

                here is an idea:
                typedef struct Tile_Render__Command_t {
                    PLATFORM_Gfx_Window *p_..;
                    f_Tile_Render_Kernel f_tile_render_kernel;
                } Tile_Render__Command;
                PLATFORM_render_chunks_as__tiles(
                        Gfx_Context*,
                        Camera*,
                        Tile_Render__Comand[],
                        u8 quant_of_commands);

        (( not ready. Finish (1) and (2) first. )
        3) Move all serialization to m_process functions. Implement a process blocking chain.

        4) Whenever possible, don't take Game as an argument and use helpers, instead take the
            actual hierarchy object as argument, and any other hierarchy arguments. Helpers should
            be left to the game-dev as they decide the Game_t composition.

        Once 1-4 is done, game engine is essentially extractible.
        Demonstrate this by extracting AG out of the engine, building, and showing it works.
        Demonstrate further by making a new project using engine.
