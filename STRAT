
    
        Okay honestly, the engine isn't in such a weird state.

        (( ready to migrate, need ui_tool update. ))
        1) Remove all asset utilization in backend. For now just do SDL, and then
        do NDS afterwards. This is mainly in sdl_ui.h and sdl_gfx_window_manager.h
        as they use the grit ui_tile indices. Make PLATFORM_ functions to set
        UI_Tile_Maps of the PLATFORM_gfx_windows. On NDS this will just result in
        modifying the graphics memory directly.

            Need to update the .xml files to gen buildable code.    
                done
            Need to add ui_background to core.                      
                skip
            Need to make sure built code works                      
                gfx_windows are registered
                ui is buggy (needs manual driving by scene, which I think is good.)
                    need to leverage Graphics_Window (CORE wrapper type) whenever
                    possible to keep window position consistent, that means
                    forwarding the wrapper types through platform.h API.

                    All PLATFORM_XYZ pointers should be wrapped in this regard.
                    Would be great if PLATFORM can specify a default gfx_window
                    and default gfx_windows for:
                        World
                        UI
                    
                    1.1) Set UI_Tiles for gfx_windows, make ./tools/ui_builder.py do this.
                        (done, don't nede to update the tool atm, just write the code in .xml)
                        NOTE:   Don't worry about it for right now, but eventually
                                have the gen'd output be the f_openers for gfx_windows.
                                This is an AG issue, and not a Lavender issue.
                    1,2) Register Misc backgrounds.
                        (still need to do)
                    1.3) Render world as a gfx_window, use render priority for layering.
                    1.4) Fix all the bugs

        (( ready for modification ))
        2) f_tile_render_kernel(Chunk_Map_Node *p.., Local_Vec3);
           PLATFORM_render_tile(gfx_context, gfx_window, Camera p.., u16 tile_texture_index, Tile_Vec3);

            f_tile_render_kernel - gives core a kernel means to manipulate tile rendering
                for example: walls.
            PLATFORM_render_tile - puts a tile into a gfx window at the given position
                relative to the camera.
            
            This gives CORE an agnostic means to control tile rendering. Can also add:
            PLATFORM_render_voxel(...); at a future date.

                For this we want good spacial locality. Currently, on NDS and SDL the following occurs:
                For each tile in chunk, get a tile_render_result, and use that to update all three
                graphics windows at the same time. If we looped over each individual window we would
                get bad spacial locality.

                here is an idea:
                typedef struct Tile_Render__Command_t {
                    PLATFORM_Gfx_Window *p_..;
                    f_Tile_Render_Kernel f_tile_render_kernel;
                } Tile_Render__Command;
                PLATFORM_render_chunks_as__tiles(
                        Gfx_Context*,
                        Camera*,
                        Tile_Render__Comand[],
                        u8 quant_of_commands);

        (( not ready. Finish (1) and (2) first. )
        3) Move all serialization to m_process functions. Implement a process blocking chain.

        4) Whenever possible, don't take Game as an argument and use helpers, instead take the
            actual hierarchy object as argument, and any other hierarchy arguments. Helpers should
            be left to the game-dev as they decide the Game_t composition.

        Once 1-4 is done, game engine is essentially extractible.
        Demonstrate this by extracting AG out of the engine, building, and showing it works.
        Demonstrate further by making a new project using engine.
