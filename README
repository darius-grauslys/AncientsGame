build           -   the output directory for building with make
core            -   platform independent game logic resides here
include         -   all core header files.
unix_opengl     -   implementation for unix opengl
nds             -   implementation for the nintendo DS

-------

Building:
Only ever run make from the base directory.
So, if your current directory doesn't have the directory
"build" in it, do not run make.

For each platform, there are the given make targets:
make <platform name>
make test_<platform name>

Even if a platform doesn't have a test suite, it still has
a test_<platform name> just to inform the user that it
has no test suite.

The base directory Makefile is to expose build targets as
well as establishing some environment variables.

Always be sure to check the platform directory's README
before building.

NOTE:
    unix_opengl does not compile at the moment.
    I wont be working on this until after
    the next push to master.

-------

Contributing:
Whenever you make a contribution to the project, make sure
to test your contribution within unix_opengl/test/

LOL - I haven't wrote jack shit for tests yet.
Writting tests for platform specific code isn't
always straightforward, or even desired (go ahead and test
all the GL calls in unix_opengl, for example.)

I will write tests for core at some point, and that is
only after I determine everything I need for core.

Please use my coding style. (Or refactor all my stuff
to your style, if you maintain your own fork.)

-------

Coding Paradigm:
OOP can so easily become hot steaming garbage.
That isn't to say it's all bad but, with that said:
Djikstra was right. Cry about it.

Honestly, OOP without inheritance/polymorphism is OKAY.
Rust has the right idea with traits.
You get serious problems when you express program structure
in the form of objects. 99 times out of 100 you can express
whatever program structure you're trying to express in the
form of functions as opposed to methods. (functions exist outside 
of objects, methods exist inside objects.)

I have a programming language in the works,
Xerxes, which I will present at LLVM 2024
which intends to do what OOP wishes it could do.

Imperative programming just works, and when done
correctly, is a much easier beast to maintain.

-------

Coding Style:

I like dense code to an extent.
-   When naming a struct field, put __ at the end followed
    by an abbreviation of that field's type.
    Why: So you can easily tell the type without checking
    it's declaration, or cursoring over it with LSP.

    Note: This is ONLY for struct fields! You do not
    need to do this for local fields of functions.
    Otherwise code gets TOO dense. You wont be in trouble
    for doing it, but only do it sparingly. An example where
    its good to do this, is if the function exceeds 100 lines
    and the local field is used extensively.

-   Wrap primitives in typedefs
    Why: Sometimes primitives are treated differently
    under certain contexts, such as the fixed point fractional
    primitives. Using typedef wrappers helps inform the
    developer how to use that primitive type.

-   Underscores between words.
    Why: Camel case is a MEME.

-   Capitialize first letter of each word in type names.
    Why: because

-   Lowercase first letter of each word in function names.
    Why: because!

-   POINTERS, prefix the name of every pointer with p_.
    If your pointer is a double or more pointer, just
    do a single p_, and include "ptr" in the noun of
    the pointer name.

    double pointer:
    p_x__ptr
    triple pointer (why?):
    p_x__ptr_ptr

    p_'s job is to signify the variable is a pointer
    but not how deep that pointer is. Use ptr_...ptr_ to do the later.

-   When naming callback functions, prepend a f_ if the callback
    does not include a pointer to it's encapsulating struct otherwise
    prepend a m_. When typedefing, the m_ and f_ are lowercased while
    the typical type naming convention still holds.
    Why: because >:(

-   When positioning parameters, parameters which find themselves in
    the name of the function should come first. For example,
    get_entity__blah_blah(Entity *entity, ...)
    Notice get_entity, this should mean entity comes first.
    Notable exception,
    get_entity__with_id__from_entity_manager(entity_manager, id)
    entity_manager is at the end of the name, but it's significant
    to the function such that it comes first.

    Don't worry too much about this, you will pick up the logic behind it.


    NOTE:
    verb_noun_preposition__noun_preposition__...
    boolean-preposition_noun_preposition__noun_preposision__...

    Example:
    is_apple__red(apple)
    get_apple__color(apple)
    does_apple_have__taste(apple)

-   Math.
    When you do math, if you need to break it out into multiple lines
    you should do so before an operator. Additionally, and I don't
    care HOW YOU FEEL about it, the semicolon is on a new line! Example,
    3 + 2 * 5 / 3;, becomes:
    3
    + 2
    * 5
    / 3
    ;
    Why: If your statement is this complicated that it warrents new lines
    then you're likely going to update it, and often enough you update
    it at the end. So you will move the semi-colon onto a new line anyways.
-   Ternaries, same deal as above. Except you ALWAYS expand it.
    x = (bool statement) ? 0 : 1;, should be:
    x =
        (bool statement)
        ? 0
        : 1
        ;
    Also, always wrap the bool statement in parens.
    Personally, I think this also makes nested ternaries viable.
    x = 
        (bool statement)
        ? (bool statement)
            ? 1
            : 2
        : 3

-------

Testing:
All game logic testing will occur in core.
All other platform directories will only have testing
for platform specific logic (as seen in the above list.)

unix_opengl should be considered as "the correct" implementation.
Meaning, if your platform implementation doesn't work but unix_opengl
does, then it's a you problem, not a game logic problem.

unix_opengl must have a test suite. All other platform directories
do not require a test suite, but should have one whenever possible.
For example, nds will not have a test suite (for now anyways.)

-------

Notes:
This project is my first serious attempt to learn and use Makefile.
As a result the Makefiles will have a LOT of comments (maybe helpful to you
if you are learning aswell.)

^ This is a lie, I will go back and add comments later.

In short, the libnds Makefile relies on recurison, and so will the Makefiles
in this project. It works. That's all I'll say in advocation of a recursive 
build system. Personally, I think using recursion is a pretty poor idea for 
project maintenance but it is what it is. I think this is one reason why Cmake 
is a better option overall.

-------

Build Configuration:
-e GENERATE_COMPILE_COMMANDS    -   This should produce a compile_commands.json file
                                    the target platform's build directory.

Use the FLAGS Makefile variable override to pass flags to gcc.
For example, if we want to define NDEBUG for unix_opengl, do the following:
make unix_opengl -e FLAGS="-DNDEBUG"

Now, as a result any invocations of helpers defined in debug.h
will be optimized out.
