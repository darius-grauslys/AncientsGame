About:

Name is temporary and subject to change.

A fun little adventure game with the goal to make playing on the NDS 
enjoyable once more. I CRAVE for a game with replay value, and a good local
multiplayer experience. I also wanted this game to be easily portable, and I
have done my best to write portable code. Always welcome to suggestions.

The game will be broken up into three versions:
    1) Exploration
    2) 3D world / Towns
    3) Building / Gathering

Currently, the project is close to reaching completion of 
the Exploration version!

-------

Building:
Run build commands from the base directory of the project.
In otherwords, your directory in which you run make commands
should include "build" as a sub-folder.

When building, provide the name of the backend implementation.
So for example, if you want to build with the nds backend:

make nds

See Porting for more information about the list of supported
backends, and how to create your own backend.

-------

Contributing:
Whenever you make a contribution to the project, if you
modify/extend core, be sure to reflect your changes
in the ./tests/ directory. See Testing.

You're not required to write tests for backend functionality
though it is recommended if it is not too difficult to do.

-------

Coding Paradigm:
I think OOP is a pyramid scheme. Rust is great for
it's usage of interfaces. Inheritance is yuck.

Djikstra was right. Cry about it.

You get serious problems when you express program structure
in the form of objects. 99 times out of 100 you can express
whatever program structure you're trying to express in the
form of functions as opposed to methods. (functions exist outside 
of objects, methods exist inside objects.)

-------

Coding Style:

Note: 
    Don't let yourself be paralyzed by my coding style. If you make a pull
    request that violates the conventions, I will be NICE and do my best to
    rename things to fit. This is only a delicate matter with ./core/*
    and ./tests/ but for backend implementations, I will probably accept
    pull requests that violate the coding style - so long as they are confined
    to just their backend, and whatever style used in said backend is consistent.

Thanks to IDEs, or even the most basic of modern text editors
we have access to tab completion, so it's not difficult to
write long descriptive names. You will notice my code is filled
with descriptive names. Here are some guidelines:
    
Naming Structs:
    - The first letter of each word is capitialized.
    - Include any "parent" relation within the struct name. See below example.
    - Each word is seperated with an underscore. With the exception
    of nouns which are usually followed by two under scores.
    Group nouns with just one underscore when it makes sense. Example:

        Chunk_Manager__Chunk_Map_Node

    The nouns Chunk, are descriptive, so we group them. Chunk Manager reasons
    about Chunk_Map_Nodes, so it has a sort of "parent" relationship. We therefore
    represent this in the struct's name. Manager and Map Node are distinctly
    different, and are seperated with two underscores.

    I would like to be more rigorous in formally defining how this naming
    convention functions, but right now it's mainly based on vibes.

Primitive Wrapping:
    We wrap primitives in this project, with the exception of bool.
    Quantity__u8 is a unsigned 8 bit integer that deals with quantities.
    Good for for-loops that do not use it's itterative value.
    For for-loops which use its itterative value, use Index__u8.
    - If the underlying typedef is a primitive, include the primitive
      at the end, so for Quantity__u8, the underlying type is uint8_t
      and therefore __u8 is added to the end.

Function Names:
    - First letter of each word is lowercase. 
    - Each word is seperated by one underscore with the exception of 
      nouns followed by prepositions.
    Example:

    get_p_entity_from__entity_manager(...)

    Be descriptive! You will notice there is not a whole lot of comments in
    the code at times, and this is because of the coding style. You should be
    easily able to tell what's happening.

    Boolean Functions:
        Function which return boolean values should be prefixed with one of
        the following:
        - is_
        - does_
        - has_

Pointers (Struct, Function, etc):
    - Prefix struct pointers with "p_" ALWAYS.
    - Prefix function pointers with "f_" with the notable exception:
        - Prefix method function pointers with "m_" where a method function
          pointer, is a function pointer that is expected to reside within
          a struct and take that struct as an argument.

    - When it comes to double pointers, put ptr after the noun.
        p_x_ptr
    - Triple pointer:
        p_x_ptr_ptr

Parameter Position:
    Note:
        I am guilty of breaking my own rules on this. Partily due to some
        old code still needing refactoring.

    Order parameters by the following:
    - Significance first
    - Size second

    For method functions, the p_this_XYZ pointer should be first.

Parameter Names:
    - Method function pointers should prefix the parameter which houses
      said method function pointer with p_this_
    - If the parameter is a primitive wrap, reflect this. Example:
        
        function(Quantity__u8 quantity_of__thingy__u8);
    
    - If the parameter is a quantity, prefix with quantity_of__
    - If the parameter is an index, include index somewhere in the name,
    - If the parameter is an enum, prefix with the_kind_of__

    This is not too big of a deal, except the 
    prim wrapping case, don't violate it.

Math:
    When you do math, if you need to break it out into multiple lines
    you should do so before an operator. Additionally, the semicolon
    should appear on a new line during such instances. Example:
        3 + 2 * 5 / 3;
    becomes:
        3
        + 2
        * 5
        / 3
        ;
    Why: If your statement is this complicated that it warrents new lines
    then you're likely going to update it, and often enough you update
    it at the end. So you will move the semi-colon onto a new line anyways.

Ternaries: 
    Same deal as above. Except you ALWAYS expand it.
    x = (bool statement) ? 0 : 1;, should be:
    x =
        (bool statement)
        ? 0
        : 1
        ;
    Also, always wrap the bool statement in parens.
    Personally, I think this also makes nested ternaries viable.
    x = 
        (bool statement)
        ? (bool statement)
            ? 1
            : 2
        : 3

-------

Testing:
I wrote a handly little script for this!
If you created new files, or directories in ./core
run the following WHILE you're in the ./tests/ directory.

    update.sh

This should include your files into the test suite automatically.
Then inside of the generated files, you will implement your own tests.

-------
